<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]>      <html class="no-js"> <!--<![endif]-->
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title></title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="style.css">
    </head>
    <body>
        <ul>
            <li><strong>...spread</strong> operator return all "items" back as individual pieces of data - spreading a string into a new array will give you an array of a bunch of single chars of that string. This is useful when the amount of something isn't known so we're saying "all" instead of manually looping through.</li>
            <li><strong>forEach</strong> is a useful and high level way to loop through an iterable</li>
            <li><strong>!args.includes(item)</strong> uses the .includes(item) on (args) to check for item in the iterable. it uses the ! prefix to say if it isn't in args, which is cool. </li>
            <li><strong>typeof num1 !== "number"</strong> let me check if the argument being passed was the right variable type</li>
            <li><strong>checking contradicting conditions</strong> return year % 4 === 0 && ( year % 100 !== 0 || year % 400 === 0)</li>
            <li><strong>WHY DOES THIS NEED THE * 10 AND /10 ???</strong> return Math.round((f - 32) * (5/9) * 10) / 10</li>
            <li><strong>const div = document.createElement('div');</strong> creates element in memory</li>
            <li><strong>.cloneNode(true)</strong> allows you to clone an element in the dom via js</li>
            <li><strong>parentNode.removeChild(child)</strong> removes child from parentNode on the DOM and returns a reference to child</li>
            <li><strong>parentNode.appendChild(childNode)</strong> appends childNode as the last child of parentNode</li>
            <li><strong>parentNode.insertBefore(newNode, referenceNode)</strong> inserts newNode into parentNode before referenceNode</li>
            <li><strong>const div = document.createElement('div');</strong> creates an element (in memory)</li>
            <li><strong>div.setAttribute('style', 'color: blue; background: white;');</strong> sets css style attribute for an element</li>

            

            

            <li><strong>.join()</strong>:: creates and returns a new string by concatenating all of the elements in an array (or an array-like object), separated by commas or a specified separator string</li>


            <h1>String Prototype Methods</h1>

                <li><strong>parseInt</strong>:: function parses a string argument and returns an integer of the specified radix (the base in mathematical numeral systems)</li>

                <li><strong>.toLowerCase()</strong> :: method returns the calling string value converted to lower case</li>

                <li><strong>.toUpperCase</strong> :: method returns the calling string value converted to uppercase</li>

                <li><strong>.split()</strong> :: method divides a String into an ordered list of substrings, puts these substrings into an array, and returns the array. The division is done by searching for a pattern; where the pattern is provided as the first parameter in the method's call</li>

            <h1>Adding / Removing Elements</h1>

                <li><strong>Array.prototype.join()</strong>:: creates and returns a new string by concatenating all of the elements in an array (or an array-like object), separated by commas or a specified separator string</li>

                <li><strong>Array.prototype.push()</strong> :: method adds one or more elements to the end of an array and returns the new array's length.</li>

                <li><strong>Array.prototype.pop()</strong> :: method removes the last element from an array and returns the removed element</li>

                <li><strong>Array.prototype.shift()</strong> :: method removes the first element from an array and returns that element</li>

                <li><strong>Array.prototype.unshift()</strong> :: method adds one or more elements to the beginning of an array and returns the new array's length</li>
            
            <h1>Finding Elements</h1>

                <li><strong>.charAt</strong> :: method returns a new string consisting of the single UTF-16 code unit located at the specified offset into the string.</li>

                <li><strong>Array.splice(index, amountOfItemsToDelete)</strong> :: method that allows you to insert new elements into the middle of an array. However, you can use this method to delete and replace existing elements as well. Changes the original array. .splice(1, 2) would remove the 2nd and 3rd element of an array. if we did .splice(1, 2, "item to add") it would still remove those items and add the string too. Array.splice(position,0,new_element_1,new_element_2,...)</li>
                
                <li><strong>String.prototype.slice(start, end)</strong> :: method extracts a portion of a string and returns it as a substring. Doesn't change the original array</li>

                <li><strong>Array.indexOf(searchElement, fromIndex)</strong> :: method returns the index of the first occurrence the element that you want to find, or -1 if the element is not found. can also to lastIndexOf</li>

                <li><strong>find(callback(element[, index[, array]])[, thisArg])</strong> :: method returns the first element in an array that satisfies a provided function. (ex: ([1, 2, 3, 4, 5].find(e => e - 2 == 3) == 5)</li>

                <li><strong>findIndex(testFn(element[, index[, array]])[, thisArg])</strong> :: method returns the index of the element that satisfies a testing function or -1 if no element passed the test. Similar to .find(), but returns the index instead of the element</li>

                <li><strong>Array.prototype.includes(element,fromIndex)</strong> :: method returns true if an array contains a given element</li>

            <h1>High-Order Methods</h1>

                <li><strong>.sort()</strong> :: sorts the elements of an array in place and returns the sorted array. The default sort order is ascending, built upon converting the elements into strings, then comparing their sequences of UTF-16 code units values. </li>

                <li><strong>array.reduce()</strong> executes a user-supplied "reducer" callback function on each element of the array, in order, passing in the return value from the calculation on the preceding element. The final result of running the reducer across all elements of the array is a single value. For example : .reduce((x, y) => x + y) will add all of the elements of the array together by taking the first index as x, then adding the rest in sequence to it. Going to take some practise. another way to see it: .reduce((accumulator, value) => accumulator + value)</li>

                <li><strong>.map()</strong> :: method creates a new array populated with the results of calling a provided function on every element in the calling array. [1, 2, 3, 4, 5].map(x => x *2) --> returns --> [2, 4, 6, 8, 10]</li>

                <li><strong>Array.prototype.filter()</strong> :: method includes the only elements in the result array if they satisfy the test in the callback function</li>
                
                <li><strong></strong></li>

                <li><strong></strong></li>

                <li><strong></strong></li>


            <li><strong></strong></li>
            <li><strong></strong></li>
        </ul>
        <div id="odinLearn">
            <ul id="myList">
                <li>this is item 1</li>
                <li id="poo">this item has an id of poo</li>
                <li id="removeMe">YESSSSSS</li>

            </ul>
        </div>  
        <script>


            const odinDiv = document.getElementById("myList");
            

            const redText = document.createElement('p')
            redText.textContent = "Hey I'm red!"
            myList.appendChild(redText);
            odinLearn.appendChild(redText.cloneNode(true)); // allows an element to be reused because of .cloneNode(true)

            myList.removeChild(removeMe);
            
            /*
            let newListItem = document.createElement("li");
            newListItem.textContent = "fart";
            myList.appendChild(newListItem);
            newListItem.setAttribute('style', 'background-color: green');       
            */

        </script>
        <!-- <script src="index.js" async defer></script> -->
    </body>
</html>

<!--
    a <p> with red text that says “Hey I’m red!”
an <h3> with blue text that says “I’m a blue h3!”
a <div> with a black border and pink background color with the following elements inside of it:
another <h1> that says “I’m in a div”
a <p> that says “ME TOO!”
Hint for this one: after creating the <div> with createElement, append the <h1> and <p> to it before adding it to the container.
-->